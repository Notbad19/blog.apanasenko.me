<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ru" lang="ru">
	<head>
 	  	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	  	<title>
	    	 Scala Functional Language (part 3)  
	  	</title>
		<link rel="stylesheet" href="/css/style.css" type="text/css" media="all"/>
	</head>
<body>
<div id="header">
	<ul id="nav" class="nav"> 
		<li id="main" class="selected"><a href="/"><strong>Home</strong><span>main page</span></a></li> 
		<li id="post"><a href="/2009/12/scala-functional-language-part-3"><strong>Blog</strong> <span>post</span></a></li>
		<li id="archive"><a href="/archive"><strong>Archive</strong></a></li> 
		<li><a href="http://ru.linkedin.com/in/apanasenko/"><strong>LinkedIn</strong> <span>&rarr;</span></a></li> 
		<li><a href="http://github.com/dieu"><strong>Github</strong> <span>&rarr;</span></a></li> 
		<li><a href="http://twitter.com/apanasenko"><strong>Twitter</strong> <span>&rarr;</span></a></li> 
	</ul>
</div>
<div id="container">			
	<div class="bar"> 
	</div> 
	<br/>
	<div id="content">
			<!-- <span id="article_buttons">
  <a id="tweet">
    <span class="balloon">tweet!</span> <img src="/images/tweet.png"/ alt="tweet"/>
  </a>
  <a href="http://feeds.feedburner.com/apanasenko">
    <span class="balloon">subscribe!</span> <img src="/images/feed.png" alt="feed"/> 
  </a>
</span>

<hr/> -->

<div class="content">
	<center><img src="http://lh6.ggpht.com/_wN3Yn5K_LYs/SyeQl3IHyBI/AAAAAAAAAJg/EUkRIIcWRRA/function%3Dmachine.jpg?imgmax=800" alt="function=machine.jpg" width="400" height="325" /></center>
<p>Сегодня я и <a href="http://reldan.livejournal.com/">Эльдар</a> попытаемся рассказать о <strong>Scala</strong> с функционального взгляда. <strong>Scala</strong> – это функциональный язык в том смысле, что каждая функция – это значение. Он предоставляет легковесный синтаксис для определения анонимных функций, а также поддерживает вложенные функции.</p>
<h4>Локальные функции</h4>
<p>В Scala мы можем определить функцию внутри другой функции.</p>
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Function</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">//9</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">j</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">localF</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="o">}</span>
    <span class="n">localF</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div><h4>Замыкания</h4>
<p><strong>Замыкание</strong> — это особый вид функции. Она определена в теле другой функции и создаётся каждый раз во время её выполнения. При этом вложенная внутренняя функция содержит ссылки на локальные переменные внешней функции. Каждый раз при выполнении внешней функции происходит создание нового экземпляра внутренней функции, с новыми ссылками на переменные внешней функции. Как видно из примера функция <strong>closure</strong> содержит свободную переменную <strong>j</strong> и связанную <strong>i</strong>.</p>
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Function</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="c1">//9</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">j</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">closure</span> <span class="k">=</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">closure</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div><p>Также можно это записать вот так:</p>
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Function</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">j</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">((</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div><p>Можно использовать подчеркивания, как <strong>плейсхолдеры</strong> параметров:</p>
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Function</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">j</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">((</span><span class="n">_:</span><span class="nc">Int</span><span class="o">)</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div><h4>Частично применимые функции</h4>
<p>Пусть в <strong>Scala</strong> есть функция :</p>
<div class="highlight"><pre><code class="scala"><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">a</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
</code></pre>
</div><p>Если вызвать sum(1) компилятор сообщит о неправильном количестве параметров. Однако есть способ заменить при вызове функции часть входных переменных подчеркиванием.</p>
<div class="highlight"><pre><code class="scala"><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> 
<span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">_:</span><span class="nc">Int</span><span class="o">))(</span><span class="mi">3</span><span class="o">)</span> <span class="c1">// (Int) =&gt; Int</span>
<span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">_:</span><span class="nc">Int</span><span class="o">,</span> <span class="n">_:</span><span class="nc">Int</span><span class="o">))(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// (Int, Int) =&gt; Int</span>
<span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="n">_:</span><span class="nc">Int</span><span class="o">,</span> <span class="n">_:</span><span class="nc">Int</span><span class="o">,</span> <span class="n">_:</span><span class="nc">Int</span><span class="o">))(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">//(Int, Int, Int) =&gt; Int</span>
</code></pre>
</div><h4>Списки</h4>
<p>Список, пожалуй, самая распространенная структура при программировании на <strong>Scala</strong>. Список подобно массивам гомогенный, т.е. содержит элементы только определенного типа.</p>
<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;bananas&quot;</span><span class="o">)</span>
</code></pre>
</div><p>Над списком в <strong>Scala</strong> можно применять функции <strong>head</strong> и <strong>tail</strong> (Lisp: car cdr). <strong>head</strong> возвращает первый элемент списка, <strong>tail</strong> &#8211; все элементы списка, кроме первого.</p>
<div class="highlight"><pre><code class="scala"><span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="s">&quot;apples&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s">&quot;oranges&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s">&quot;bananas&quot;</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
</code></pre>
</div><p>Сортировка вставками используя head и tail:</p>
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Function</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">iSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)))</span> <span class="c1">//List(0, 1, 2, 3, 4, 5)</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">iSort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
    <span class="k">else</span> <span class="n">insert</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">,</span> <span class="n">iSort</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">))</span>
  <span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="n">x</span><span class="o">::</span><span class="n">xs</span>
    <span class="k">else</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
<span class="o">}</span>
</code></pre>
</div><p>Тоже самое можно записать несколько иначе использую паттерн матчинг(Pattern matching)<br />
<blockquote><br />
<strong>Pattern matching</strong> &#8211; это сравнение с образцом, сопоставление с шаблоном.</blockquote></p>
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Function</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">iSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)))</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">iSort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">iSort</span><span class="o">(</span><span class="n">xs1</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
    <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div><p>Кроме в работе с <strong>pattern matching</strong>&#8216;ом часто используются так называемые <strong>case class</strong>&#8217;ы, которые имеют некторые особенности. При объявлении компилятор:</p>
<ol>
	<li>cоздет функцию-конструктор с именем, совпадающим с класом</li>
	<li>имплиментирует в классе toString, equals, hashCode на основе аргументов конструктора</li>
	<li>создает селекторы для всех аргументов конструктора</li>
</ol>
<p>Мы их использовали в предыдущей <a href="http://blog.apanasenko.me/2009/12/scala-actors-part-2/">статье</a> в примере с пинг-понгом.</p>
<h4>Работа со списками</h4>
<p><strong>Map</strong> принимает <strong>List[Т]</strong> и функцию <strong>Т =&gt; U</strong>. Возвращает <strong>List[U]</strong></p>
<div class="highlight"><pre><code class="scala"><span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// List(1, 0, 1, 0, 1)</span>
<span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;bananas&quot;</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">mkString</span><span class="o">)</span> <span class="c1">// List(selppa, segnaro, sananab)</span>
</code></pre>
</div><p><strong>FlatMap</strong> схож с <strong>Map</strong>, но вызывает конкатенацию всех результатов функции.</p>
<div class="highlight"><pre><code class="scala"><span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;bananas&quot;</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span> <span class="c1">// List(List(a, p, p, l, e, s), List(o, r, a, n, g, e, s), List(b, a, n, a, n, a, s))</span>
<span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;bananas&quot;</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">_</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span> <span class="c1">// List(a, p, p, l, e, s, o, r, a, n, g, e, s, b, a, n, a, n, a, s)</span>
</code></pre>
</div><p><strong>Foreach</strong>:</p>
<div class="highlight"><pre><code class="scala"><span class="k">object</span> <span class="nc">Function</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span><span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">_</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">sum</span><span class="o">)</span> <span class="c1">// 15</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div><p><strong>Filter</strong>:</p>
<div class="highlight"><pre><code class="scala"><span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span><span class="c1">// List(4, 5)</span>
</code></pre>
</div><p>Также есть find, forall, exists, find, partition, takeWhile, dropWhile</p>
<h4>Свертки</h4>
<blockquote>
<p>В программировании <strong>свёртка</strong> (англ. <strong>folding</strong>, также известна как reduce и accumulate) — функция высшего порядка, которая производит преобразование структуры данных к единственному атомарному значению при помощи заданной функции. Операция свёртки часто используется в функциональном программировании при обработке списков.<br />
Свёртка может быть обобщена на произвольный алгебраический тип данных при помощи понятия «катаморфизм» из теории категорий.</blockquote></p>
<div class="highlight"><pre><code class="scala"><span class="n">fold</span> <span class="n">left</span> <span class="o">/:</span>
<span class="n">fold</span> <span class="n">right</span> <span class="o">:\</span>
</code></pre>
</div><p>Сумма всех элементов:</p>
<div class="highlight"><pre><code class="scala"><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">_</span><span class="o">)</span>
<span class="o">(</span><span class="mi">0</span> <span class="o">/:</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">))</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="n">_</span><span class="o">)</span>
</code></pre>
</div><p>Эквивалентно:</p>
<div class="highlight"><pre><code class="scala"><span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">6</span><span class="o">).</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">_+_</span><span class="o">)</span>
</code></pre>
</div><p>Произведение всех элементов</p>
<div class="highlight"><pre><code class="scala"><span class="k">def</span> <span class="n">product</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="n">_</span><span class="o">)</span>
</code></pre>
</div>

	
		<h4>Posted 15 Dec 2009 by Anton Panasenko | tags:
		 
			
				<a href="/search/label/fl">fl</a>,
			 
		 
			
				<a href="/search/label/fp">fp</a>,
			 
		 
					
				<a href="/search/label/jvm">jvm</a>
			 
		 
			
				and <a href="/search/label/scala">scala</a>.
			 
		
	</h4>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  (function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = 'http://dieu.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js"></script>
<script type="text/javascript">
	$('#main').removeClass('selected');
	$('#post').addClass('selected');
</script>

<!--

-->

	</div>
</div>
<!-- <div id="footer">
	<a href="">Source code</a>
</div> -->

 <script type="text/javascript">
var disqus_shortname = 'dieu';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.src = 'http://disqus.com/forums/dieu/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
 </script>

  
<!-- Yandex.Metrika counter -->
<div style="display:none;"><script type="text/javascript">
(function(w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter445478 = new Ya.Metrika(445478);
             yaCounter445478.clickmap(true);
             yaCounter445478.trackLinks(true);
        
        } catch(e) { }
    });
})(window, 'yandex_metrika_callbacks');
</script></div>
<script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript" defer="defer"></script>
<noscript><img src="//mc.yandex.ru/watch/445478" style="position:absolute; left:-9999px;" alt="" /></noscript>
<!-- /Yandex.Metrika counter -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-6891853-5']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>