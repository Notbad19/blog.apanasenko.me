---
layout: post
title: Erlang (gen_server)
excerpt: Про Erlang достаточно много написано на русском (Вики), по этому интереснее конкретные, простые примеры кода. А вот их днем с огнем не сыщешь, не в англоязычном интернете, не тем более в русском... Надо эту ситуацию, как то менять и начну пожалуй с себя :)
published: true
categories:
- erlang
- gen_server
- mapreduce
---

Про Erlang достаточно много написано на русском (<a href="http://ru.wikipedia.org/wiki/Erlang">Вики</a>), по этому интереснее конкретные, простые примеры кода. А вот их днем с огнем не сыщешь, не в англоязычном интернете, не тем более в русском... Надо эту ситуацию, как то менять и начну пожалуй с себя :)


Сегодня я попробую показать простое использование gen_server'a, для имитации <a href="http://ru.wikipedia.org/wiki/MapReduce">MapReduce</a>.

{% highlight erlang %}
-module (console, [Name]).
-behaviour (gen_server).

-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

-export([start/1]).
-export([send/1, mapReduce/4, addWorker/1, result/2, getResult/1, history/0]).

start(Args) ->
 gen_server:start_link({global, Name}, {?MODULE, Name}, Args, []). 

init(Args) ->
 lists:foreach(
  fun(Elem) ->
   Elem:connect({?MODULE, Name})
  end,
  Args),
    StateServer = dict:store(reduce, dict:new(),
     dict:store(result, dict:new(), 
      dict:store(jobs, Args, 
       dict:store(message, [], 
        dict:new())))),
    {ok, StateServer}.
 
send(Msg) ->
 gen_server:call({global, Name}, {message, Msg}).
 
mapReduce(Id, Map, Args, Reduce) -> 
 reduce(Id, Reduce),
 gen_server:call({global, Name}, {message, map, Id, Map, Args}).
 
reduce(Id, Fun) ->
 gen_server:call({global, Name}, {message, reduce, Id, Fun, []}).
 
addWorker(Job) ->
 gen_server:call({global, Name}, {jobs, Job}).
 
result(Id, Result) ->
 gen_server:cast({global, Name}, {result, Id, Result}).
 
history() ->
 gen_server:call({global, Name}, {history}).
 
getResult(Id) ->
 gen_server:call({global, Name}, {history, Id}). 

handle_call({message, Msg, Id, Fun, Args}, _From, StateServer) ->
 ReturnMsg = case Msg of
  map ->
   NewState = dict:append(message, Msg, StateServer),
   Jobs = dict:fetch(jobs, NewState),
   lists:foreach(
     fun(Elem) ->
      Elem:run(Id, Fun, Args)
     end,
     Jobs),
   "Run function";   
  reduce -> 
   State = dict:append(message, Msg, StateServer),
   Reduce = dict:fetch(reduce, State),
   NewReduce = dict:store(Id, Fun, Reduce),
   NewState = dict:store(reduce, NewReduce, State),
   "Add reduce";
  true ->
   NewState = StateServer,
   "Faild msg"
 end,
 {reply, ReturnMsg, NewState};
 
handle_call({history}, _From, StateServer) -> 
 {reply, dict:fetch(message, StateServer), StateServer};
handle_call({history, Id}, _From, StateServer) ->
 DictResult = dict:fetch(result, StateServer),
 Result = 
  case dict:is_key(Id, DictResult) of
   true ->
    dict:fetch(Id, DictResult);
   false ->
    nil
  end,
 {reply, Result, StateServer};
handle_call({jobs, Job}, _From, StateServer) ->
 NewState = dict:append(jobs, Job, StateServer),
 Job:connect({?MODULE, Name}),
 {reply, Job, NewState}.

handle_cast({result, Id, Result}, StateServer) -> 
 DictResult = dict:fetch(result, StateServer),
 NewState = case dict:is_key(Id, DictResult) of
  true ->
   Jobs = length(dict:fetch(jobs, StateServer)),
   NewResult = dict:append(Id, Result, DictResult),
   State = dict:store(result, NewResult, StateServer),
   ResultId = length(dict:fetch(Id, NewResult)),
   Results = dict:fetch(Id, NewResult),
   case (Jobs == ResultId) of
    true ->
     Reduce = dict:fetch(reduce, State),
     case dict:is_key(Id, Reduce) of
      true ->
       Fun = dict:fetch(Id, Reduce),
       EndResult = Fun(Results),
       dict:store(result, dict:store(Id, EndResult, NewResult), State);       
      false ->
       EndResult = "Faild",
       io:format("sddd~n"),
       dict:store(result, dict:store(Id, EndResult, NewResult), State)
     end;
    false ->
     State
   end;
  false ->
   NewResult = dict:store(Id, [Result], DictResult),
   State = dict:store(result, NewResult, StateServer)
 end,
 {noreply, NewState}.
 
handle_info(_Message, StateServer) -> 
 {noreply, StateServer}.
terminate(_Reason, _StateServer) -> 
 ok.
code_change(_OldVersion, StateServer, _Extra) -> 
 {ok, StateServer}.
{% endhighlight %}

В этом листинге используется gen_server для обработки сообщений/команд и управления "кластером".

{% highlight erlang %}
-module (jobs, [Name]).
-behaviour (gen_server).

-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

-export([start/0]).
-export ([run/3, connect/1, history/1]).

start() -> 
 gen_server:start_link({global, Name}, {?MODULE, Name}, [], []).
 
init([]) ->
    StateServer = dict:store(node, [], 
     dict:new()),
    {ok, StateServer}.

run(Id, Fun, Args) -> 
 gen_server:cast({global, Name}, {Id, Fun, Args}).

connect(Node) ->
 gen_server:cast({global, Name}, {node, Node}).

history(Id) -> 
 gen_server:call({global, Name}, {history, Id}).

handle_call({history, Id}, _From, StateServer) ->
 Reply = case dict:is_key(Id, StateServer) of
  true -> 
   dict:fetch(Id, StateServer);
  false ->
   nil
  end, 
 {reply, Reply, StateServer}.
 
handle_cast({Id, Fun, Args}, StateServer) -> 
 Reply = Fun(Args),
 NewState = dict:store(Id, Reply, StateServer),
 Node = dict:fetch(node, StateServer),
 lists:foreach(
  fun(Elem) ->
    Elem:result(Id, Reply)
  end,
  Node),
 {noreply, NewState};
handle_cast({node, Node}, StateServer) ->
 NewState = dict:append(node, Node, StateServer),
 {noreply, NewState}.
 
handle_info(_Message, StateServer) -> 
 {noreply, StateServer}.
terminate(_Reason, _StateServer) -> 
 ok.
code_change(_OldVersion, StateServer, _Extra) -> 
 {ok, StateServer}.
{% endhighlight %}

А в этом уже и происходит исполнение какой-то функции и возврат результата по запросу от управляющего процесса.

В видео видно как этот код собирается в "кластер" и запускается на простое задание.

<object height="344" width="640"><param name="movie" value="http://www.youtube.com/v/fHIPNQItTvg&hl=en&fs=1">
</param>
<param name="allowFullScreen" value="true">
</param>
<param name="allowscriptaccess" value="always">
</param>
<embed src="http://www.youtube.com/v/fHIPNQItTvg&hl=en&fs=1" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="640" height="344"></embed></object>